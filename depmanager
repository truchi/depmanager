#!/bin/bash
#
# Dependencies managment
# Author: Romain TRUCHI (https://github.com/truchi)
#
# # depmanager
#
# Checks, diffs, installs or updates your dependencies.
# System, NodeJS, Rust.
#
# # Dependencies
#
# bash, wget (remote CSV only)
#
# # Usage
#
# $ depmanager check --directory ~/my/dir --node ~/my/node.csv
#
# # Configuration
#
# `$DEPMANAGER_DIR="/path/to/your/dir"` # No trailing slash
# Defaults to "$HOME/.config/depmanager"

###################################################
# vars
###################################################

SYSTEM_MANAGERS=(apt yum pacman)
NON_SYSTEM_MANAGERS=(node rust)
MANAGERS=("${SYSTEM_MANAGERS[@]}" "${NON_SYSTEM_MANAGERS[@]}")

SYSTEM_MANAGER=
COMMAND=
QUIET=false
YES=false
SIMULATE=false

declare -A DEFAULTS
declare -A PATHS
declare -A __cache_detect_path
declare -A __cache_detect_manager

DEFAULTS[dir]="$HOME/.config/depmanager"
for manager in "${MANAGERS[@]}"; do
  DEFAULTS[$manager]="$manager.csv"
done

NO_COLOR=$(tput sgr0)
BOLD=$(tput bold)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)

###################################################
# utils/print
###################################################

print_separator() {
  $QUIET && return
  echo "${MAGENTA}~~~~~~~~~~~~~~~~~~~~~${NO_COLOR}"
}

print_date() {
  echo ${MAGENTA}[$(date +"%Y-%m-%d %H:%M:%S")]${NO_COLOR}
}

print_error() {
  echo "$(print_date) ${RED}${BOLD}âœ—${NO_COLOR} $@"
}

print_warning() {
  $QUIET && return
  echo "$(print_date) ${YELLOW}${BOLD}!${NO_COLOR} $@"
}

print_success() {
  $QUIET && return
  echo "$(print_date) ${GREEN}${BOLD}âœ”${NO_COLOR} $@"
}

print_info() {
  $QUIET && return
  echo "$(print_date) ${BLUE}${BOLD}i${NO_COLOR} $@"
}

print_custom() {
  $QUIET && return
  echo "$(print_date) $@"
}

print_confirm() {
  # Auto confirm if flag is given
  $YES && return

  # Prompt confirmation message
  local message="$(print_date) ${YELLOW}${BOLD}?${NO_COLOR} ${BOLD}$1${NO_COLOR} ${YELLOW}(Y)${NO_COLOR}"
  read -p "$message " -n 1 -r

  # Carriage return if user did not press enter
  [[ ! "$REPLY" =~ ^$ ]] && echo

  # Accepts <Enter>, Y or y
  [[ "$REPLY" =~ ^[Yy]$ || "$REPLY" =~ ^$ ]]
}

print_version() {
  echo "${YELLOW}v0.0.1${NO_COLOR}"
}

print_summary() {
  echo "${BOLD}${GREEN}depmanager${NO_COLOR} $(print_version)
${MAGENTA}https://github.com/truchi/depmanager${NO_COLOR}"
}

print_help() {
  local command=$(basename $0)

  echo "${BOLD}${BLUE}Usage:${NO_COLOR}
  ${BOLD}${GREEN}$command${NO_COLOR} [-h|--version]
  ${BOLD}${GREEN}$command${NO_COLOR} [-v|--help]
  ${BOLD}${GREEN}$command${NO_COLOR} <command> [options]

${BOLD}${BLUE}Description:${NO_COLOR}
  ${WHITE}Manages your dependencies.

  List packages you depend on in CSV files (system.csv, node.csv, rust.csv).
  Export \$DEPMANAGER_DIR (containing these files) environment variable (defaults to \$HOME/.config/depmanager).${NO_COLOR}

${BOLD}${BLUE}Commands:${NO_COLOR}
  s${WHITE},${NO_COLOR} status                      ${WHITE}Produces a report with regard to the CSV files${NO_COLOR}
  i${WHITE},${NO_COLOR} install                     ${WHITE}Installs packages in the CSV files${NO_COLOR}
  u${WHITE},${NO_COLOR} update                      ${WHITE}Updates packages in the CSV files${NO_COLOR}

${BOLD}${BLUE}Options:${NO_COLOR}
  -a${WHITE},${NO_COLOR} --apt <path|url|false>     ${WHITE}Blah${NO_COLOR}
  -y${WHITE},${NO_COLOR} --yum <path|url|false>     ${WHITE}Blah${NO_COLOR}
  -p${WHITE},${NO_COLOR} --pacman <path|url|false>  ${WHITE}Blah${NO_COLOR}
  -n${WHITE},${NO_COLOR} --node <path|url|false>    ${WHITE}Blah${NO_COLOR}
  -r${WHITE},${NO_COLOR} --rust <path|url|false>    ${WHITE}Blah${NO_COLOR}
  -Q${WHITE},${NO_COLOR} --quiet                    ${WHITE}Blah${NO_COLOR}
  -Y${WHITE},${NO_COLOR} --yes                      ${WHITE}Blah${NO_COLOR}
  -S${WHITE},${NO_COLOR} --simulate                 ${WHITE}Blah${NO_COLOR}

${BOLD}${BLUE}Links:${NO_COLOR}
  ${WHITE}- Repository${NO_COLOR}                   ${MAGENTA}https://github.com/truchi/depmanager${NO_COLOR}
  ${WHITE}- Website${NO_COLOR}                      ${MAGENTA}https://github.com/truchi/depmanager${NO_COLOR}
  ${WHITE}- Documentation${NO_COLOR}                ${MAGENTA}https://github.com/truchi/depmanager${NO_COLOR}
"
}

print_pre_run() {
  print_info "${BOLD}Depmanager directory ${NO_COLOR}: ${BLUE}$(get_path dir)${NO_COLOR}"

  if is_set $SYSTEM_MANAGER; then
    local version=$($SYSTEM_MANAGER --version)
    print_info "${BOLD}Your system's manager${NO_COLOR}: ${BLUE}$SYSTEM_MANAGER${NO_COLOR} ($version)"
  else
    print_warning "${BOLD}Your system's package manager is not supported${NO_COLOR}"
  fi

  print_separator

  local i=0
  local messages=""
  for manager in "${MANAGERS[@]}"; do
    # Ignore system manager which are not detected on user's system
    if is_system_manager $manager; then
      detect_manager $manager
      [[ $(code_to_boolean $?) != true ]] && continue
    fi

    local message="${BOLD}$manager${NO_COLOR} "
    if   is_bypassed $manager; then message="$message ${BLUE}bypassed${NO_COLOR}"
    elif detect_path $manager; then message="$message ${GREEN}$(get_path $manager)${NO_COLOR}"
    else                            message="$message ${YELLOW}$(get_path $manager)${NO_COLOR}"
    fi

    if   is_bypassed $manager; then  messages="$messages info $message"
    elif detect_path $manager; then  messages="$messages success $message"
    else                             messages="$messages warning $message"
    fi

    i=$(($i + 1))
  done

  print_justified $i 3 "$messages"
  print_separator

  ! $SIMULATE && print_info "(Tip: run with --simulate first)"

  # Ask for confirmation
  $SIMULATE \
    && print_confirm "Simulate $COMMAND?" \
    || print_confirm "Run $COMMAND?"
}

print_justified() {
  local arr=$@
  local n_rows=$1
  local n_cols=$2
  local max_lengths

  for i in $(seq 0 $(($n_cols - 1))); do
    local col=$(matrix_get_column $i $arr)
    local max_length=-1

    for word in $col; do
      word=$(echo -e "$word" | sed "s/$(echo -e "")[^m]*m//g")
      local length=${#word}
      (( $length > $max_length )) && max_length=$length
    done

    max_lengths[$i]=$max_length
  done

  for i in $(seq 0 $(($n_rows - 1))); do
    local row=($(matrix_get_row $i $arr))
    local level="${row[0]}"
    local message=""

    for i in $(seq 1 $(($n_cols - 1))); do
      local cell=${row[$i]}
      local word=$(echo -e "$cell" | sed "s/$(echo -e "")[^m]*m//g")
      local cell_length=${#cell}
      local word_length=${#word}
      local max_length=${max_lengths[$i]}
      local pad=$(($max_length + 2))
      (( $word_length != $cell_length )) && pad=$(($pad + $cell_length - $word_length))

      message="$message$(printf "%-${pad}s" "$cell")"
    done

    print_${level} "$message"
  done
}

###################################################
# utils/helpers
###################################################

#
# Returns true if $1 starts with /, false otherwise
#
is_absolute() {
  [[ "$1" =~ / ]]
}

#
# Returns true if $1 starts with https?://, false otherwise
#
is_url() {
  [[ "$1" =~ https?:// ]]
}

#
# Returns true is $1 is set, false otherwise
#
is_set() {
  [[ ! -z "$1" ]]
}

#
# Returns true if file $1 exists, false otherwise
#
file_exists() {
  [[ -f "$1" ]]
}

#
# Returns true if url $1 exists, false otherwise
#
url_exists() {
  wget -q --spider "$1"
}

#
# Returns true if $1 is found on the system, false otherwise
#
command_exists() {
  command -v "$1" >/dev/null 2>&1
}

#
# Returns true if $1 is in `SYSTEM_MANAGERS`, false otherwise
#
is_system_manager() {
  [[ " ${SYSTEM_MANAGERS[@]} " =~ " $1 " ]]
}

#
# Echos true if $1 is 0, false otherwise
#
code_to_boolean() {
  [[ $1 == 0 ]] && echo true || echo false
}

matrix_get_row() {
  local arr=$@
  local row=$1
  local n_rows=$2
  local n_cols=$3
  local first=$(($row * $n_cols))
  local last=$((($row + 1) * $n_cols - 1))
  local cells=""

  local i=-4
  for cell in ${arr[@]}; do
    i=$(($i + 1))
    (( $i < $first )) && continue
    (( $i > $last  )) && break
    cells="$cells $cell"
  done

  echo $cells
}

matrix_get_column() {
  local arr=$@
  local column=$1
  local n_cols=$3
  local cells=""

  local i=-4
  for cell in ${arr[@]}; do
    i=$(($i + 1))
    (( $i < 0)) && continue

    local n=$(($i % $n_cols))
    (( $n != $column )) && continue
    cells="$cells $cell"
  done

  echo $cells
}

###################################################
# utils/string
###################################################

string_raw_length() {
  local str="$1"
  echo ${#str}
}

string_length() {
  local str="$1"
  str=$(echo -e "$str" | sed "s/$(echo -e "")[^m]*m//g")
  echo ${#str}
}

string_is_number() {
  local arg=("${!1}") # May be an array
  local re='^[0-9]+$'
  [[ "${arg[@]}" =~ $re ]]
}

string_is_empty() {
  [[ -z "$1" ]]
}

string_pad_right() {
  local str="$1"
  local n="$2"
  printf "%-${n}s" "$str"
}

###################################################
# utils/array
###################################################

array_length() {
  local array=("${!1}")
  echo "${#array[*]}"
}

###################################################
# utils/table
###################################################

table_print() {
  local pad=2
  local title=$1
  local headers=("${!2}")
  local levels=("${!3}")
  local data=("${!4}")

  local column_count=$(string_is_number headers[@] && echo "$headers" || echo $(array_length headers[@]))
  local row_count=$(array_length levels[@])

  local total_length
  local column_length=()
  for column_index in $(seq 0 $(($column_count - 1))); do
    local column=()
    table_get_column $column_index $column_count data[@]

    local length=-1
    for cell in "${column[@]}"; do
      local l=$(string_length "$cell")
      (( $l > $length )) && length=$l
    done

    column_length[$column_index]=$length
    total_length=$(($total_length + $length))
  done
  total_length=$(($total_length - $pad))

  local title_pad="$(string_pad_right "" $((($total_length - $(string_length "$title")) / 2)))"
  print_custom "  $title_pad$title"

  for row_index in $(seq 0 $(($row_count - 1))); do
    local message=""
    local level="${levels[$row_index]}"
    local row=()
    table_get_row $row_index $column_count data[@]

    for column_index in $(seq 0 $(($column_count - 1))); do
      local cell="${row[$column_index]}"
      local length=$(string_length "$cell")
      local raw_length=$(string_raw_length "$cell")

      message="$message$(string_pad_right "$cell" $(($pad + ${column_length[$column_index]} + $raw_length - $length)))"
    done

    print_${level} "$message"
  done
}

table_get_row() {
  local row_index=$1
  local column_count=$2
  local data=("${!3}")
  local first=$(($row_index * $column_count))
  local last=$((($row_index + 1) * $column_count - 1))

  local i=-1
  for cell in "${data[@]}"; do
    i=$(($i + 1))

    (( $i < $first )) && continue
    (( $i > $last  )) && break
    row+=("$cell")
  done
}

table_get_column() {
  local column_index=$1
  local column_count=$2
  local data=("${!3}")

  local i=-1
  for cell in "${data[@]}"; do
    i=$(($i + 1))

    (( $(($i % $column_count)) == $column_index )) \
      && column+=("$cell") \
      || continue
  done
}

###################################################
# utils/functions
###################################################

#
# Sets `DIR` according to (in this precedence order):
# - env variable (relative to home)
# - default path
#
resolve_dir() {
  local dir=""

  # If env variable is defined
  if is_set "$DEPMANAGER_DIR"; then
    # Use user's dir
    dir="$DEPMANAGER_DIR"

    # Relative to home
    ! is_absolute "$dir" && dir="$HOME/$dir"
  else
    # Use default dir
    dir="${DEFAULTS[dir]}"
  fi

  PATHS[dir]="$dir"
}

#
# Sets `PATHS[$1]` according to (in this precedence order):
# - cli arg          (relative to current workin directory)
# - default variable (relative to `DIR`)
#
resolve_path() {
  local manager="$1"
  local file=""

  # If file is given in args
  if is_set "${PATHS[$manager]}"; then
    # Use file arg
    file="${PATHS[$manager]}"

    # Relative to current working dir
    ! is_absolute "$file" && ! is_url "$file" && file="$(pwd)/$file"
  else
    # Use default file, relative to PATHS[dir]
    file="${PATHS[dir]}/${DEFAULTS[$manager]}"
  fi

  PATHS[$manager]="$file"
}

#
# Returns true if ${PATHS[$1]} exists (file/url), false otherwise
# With cache
#
detect_path() {
  local manager="$1"
  local file="${PATHS[$manager]}"

  # If already found, do not try to find again
  if is_set "${__cache_detect_path[$manager]}";then
    "${__cache_detect_path[$manager]}"
    return
  fi

  # Check for existence of file/url
  if (is_url "$file" && url_exists "$file") || file_exists "$file"; then
    __cache_detect_path[$manager]=true
    true
  else
    __cache_detect_path[$manager]=false
    false
  fi
}

#
# Returns true if the manager is found on the system, false otherwise
# With cache (system managers only)
#
detect_manager() {
  local manager="$1"

  # If already detected, do not try to detect again
  if is_set "${__cache_detect_manager[$manager]}"; then
    "${__cache_detect_manager[$manager]}"
    return
  fi

  # Detection
  if command_exists "${manager}_detect" && ${manager}_detect; then
    is_system_manager $manager && __cache_detect_manager[$manager]=true
    true
  else
    is_system_manager $manager && __cache_detect_manager[$manager]=false
    false
  fi
}

#
# Sets `SYSTEM_MANAGER` to the first system manager detected
#
detect_system() {
  is_set $SYSTEM && return

  for manager in "${SYSTEM_MANAGERS[@]}"; do
    if detect_manager $manager; then
      SYSTEM_MANAGER="$manager"
      return
    fi
  done
}

#
# Returns true if `${PATHS[$1]}` equals false
#
is_bypassed() {
  [[ "${PATHS[$1]}" == false ]]
}

#
# Echos `${PATHS[$1]}`
#
get_path() {
  echo "${PATHS[$1]}"
}

# matrix_get_column() {
  # local n_lines=$1
  # local n_cols=$2
  # local matrix=$@
# }

###################################################
# managers/apt
###################################################

#
# Returns true if apt is found on the system, false otherwise
#
apt_detect() {
  command_exists apt && command_exists apt-cache && command_exists dpkg
}

apt_status() {
  local file=$(get_path apt)

  while IFS=, read -r dependency; do
    echo dep:$dependency
    echo local:$(apt_get_local_version $dependency)
    echo remote:$(apt_get_remote_version $dependency)
  done < $file
}

apt_is_installed() {
  local dependency=$1
  local list=$(apt list --installed $dependency 2>/dev/null | sed 's/Listing...//')

  echo $list | grep "^$dependency/" | grep '\[installed' >/dev/null 2>&1
}

apt_get_local_version() {
  apt-cache policy $1 | sed '2q;d' | sed 's/  Installed: \(.*\).*/\1/'
}

apt_get_remote_version() {
  apt-cache policy $1 | sed '3q;d' | sed 's/  Candidate: \(.*\).*/\1/'
}

###################################################
# main
###################################################

#
# Parses args, filling the appropriate global variables
#
parse_args() {
  # Print summary, version and help
  if [[ $# == 0 ]]; then
    print_summary
    echo
    print_help
    exit
  elif [[ $# == 1 ]]; then
    if [[ "$1" == "--version" || "$1" == "-v" ]]; then
      print_version
      exit
    elif [[ "$1" == "--help" || "$1" == "-h" ]]; then
      print_help
      exit
    fi
  fi

  # Get command
  case "$1" in
    s|status)
      COMMAND="status";;
    i|install)
      COMMAND="install";;
    u|update)
      COMMAND="update";;
    *)
      print_error Unknown command: $1
      exit
  esac

  # Get options
  while [[ $# -gt 1 ]]; do
    case "$2" in
      -a|--apt)
        PATHS[apt]="$3"; shift; shift;;
      -y|--yum)
        PATHS[yum]="$3"; shift; shift;;
      -p|--pacman)
        PATHS[pacman]="$3"; shift; shift;;
      -n|--node)
        PATHS[node]="$3"; shift; shift;;
      -r|--rust)
        PATHS[rust]="$3"; shift; shift;;
      -Q|--quiet)
        QUIET=true; shift;;
      -Y|--yes)
        YES=true; shift;;
      -S|--simulate)
        SIMULATE=true; shift;;
      -*)
        if [[ "$2" = "-" ]]; then
          print_error "There might be an error in your command, found a lone '-'"
          exit
        fi

        local flags="${2:1}"
        local non_flags=$(echo "$flags" | sed 's/[QYS]//g')

        [[ "$flags" == *"Q"* ]] && QUIET=true
        [[ "$flags" == *"Y"* ]] && YES=true
        [[ "$flags" == *"S"* ]] && SIMULATE=true

        if is_set "$non_flags"; then
          print_error "Unknown flags: ${BOLD}$non_flags${NO_COLOR}"
          exit
        fi

        shift;;
      *)
        print_error "Unknown option: ${BOLD}$2${NO_COLOR}"
        exit
    esac
  done
}

run() {
  local managers=($SYSTEM_MANAGER "${NON_SYSTEM_MANAGERS[@]}")

  for manager in "${managers[@]}"; do
    is_bypassed $manager      && continue
    ! detect_manager $manager && continue
    ! detect_path $manager    && continue

    print_separator
    print_info ${BOLD}$manager${NO_COLOR}

    run_${COMMAND} $manager
    # continue
    # if command_exists ${manager}_${COMMAND}; then
      # ${manager}_${COMMAND}
    # else
      # print_warning "Oops! $COMMAND is not implemented for ${manager}, ..."
    # fi
  done
}

run_status() {
  local manager=$1
  local file=$(get_path $manager)
  local messages="info Package ${BOLD}${RED}Local${NO_COLOR} Remote"
  local i=1

  while IFS=, read -a line; do
    local dependency=${line[0]}
    local installed=false
    local local_version="NONE"
    local remote_version=$(${manager}_get_remote_version $dependency)
    ! is_set $remote_version && remote_version="NONE"

    if ${manager}_is_installed $dependency; then
      installed=true
      local_version=$(${manager}_get_local_version $dependency)
    fi

    if ! $installed; then
      messages="$messages error"
    elif [[ $local_version == $remote_version ]]; then
      messages="$messages success"
    else
      messages="$messages warning"
    fi

    messages="$messages ${BOLD}$dependency${NO_COLOR} $local_version $remote_version"
    i=$(($i + 1))
  done < $file

  print_justified $i 4 "$messages"
}

run_install() {
  echo INSTALL
}

run_update() {
  echo UPDATE
}

#
# Main
# Parses arguments, resolves files, run specified command
#
main() {
  declare -A table
  local title="The ${RED}title${NO_COLOR}"
  local headers=("h1 a" "h2 b" "h3 cc")
  # local headers=4
  local levels=("info" "warning" "error")
  local data=(
    "row1 col1" "row1 col2" "row1 col3"
    "row2 col1 ${RED}ddd${NO_COLOR}" "row2 col2" "row2 col3"
    "row3 col1" "row3 col2" "testrow3 col3"
  )
  table_print "$title" headers[@] levels[@] data[@]
  exit

  parse_args $@
  resolve_dir
  detect_system

  for manager in "${MANAGERS[@]}"; do
    is_bypassed $manager && continue

    resolve_path $manager
    detect_path $manager
    detect_manager $manager
  done

  if print_pre_run; then
    print_info Go!
    run
    # run_${COMMAND}
  else
    print_info Bye!
    exit
  fi
}

# Run
main $@


